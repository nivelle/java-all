ğŸ–•æ¬¢è¿å…³æ³¨æˆ‘çš„å…¬ä¼—å·â€œå½¤å“¥è¯»æºç â€ï¼ŒæŸ¥çœ‹æ›´å¤šæºç ç³»åˆ—æ–‡ç« , ä¸å½¤å“¥ä¸€èµ·ç•…æ¸¸æºç çš„æµ·æ´‹ã€‚ 

ï¼ˆæ‰‹æœºæ¨ªå±çœ‹æºç æ›´æ–¹ä¾¿ï¼‰

---

## é—®é¢˜

ï¼ˆ1ï¼‰é‡å…¥é”æ˜¯ä»€ä¹ˆï¼Ÿ

ï¼ˆ2ï¼‰ReentrantLockå¦‚ä½•å®ç°é‡å…¥é”ï¼Ÿ

ï¼ˆ3ï¼‰ReentrantLockä¸ºä»€ä¹ˆé»˜è®¤æ˜¯éå…¬å¹³æ¨¡å¼ï¼Ÿ

ï¼ˆ4ï¼‰ReentrantLocké™¤äº†å¯é‡å…¥è¿˜æœ‰å“ªäº›ç‰¹æ€§ï¼Ÿ

## ç®€ä»‹

Reentrant = Re + entrantï¼ŒReæ˜¯é‡å¤ã€åˆã€å†çš„æ„æ€ï¼Œentrantæ˜¯enterçš„åè¯æˆ–è€…å½¢å®¹è¯å½¢å¼ï¼Œç¿»è¯‘ä¸ºè¿›å…¥è€…æˆ–è€…å¯è¿›å…¥çš„ï¼Œæ‰€ä»¥Reentrantç¿»è¯‘ä¸ºå¯é‡å¤è¿›å…¥çš„ã€å¯å†æ¬¡è¿›å…¥çš„ï¼Œå› æ­¤ReentrantLockç¿»è¯‘ä¸ºé‡å…¥é”æˆ–è€…å†å…¥é”ã€‚

é‡å…¥é”ï¼Œæ˜¯æŒ‡ä¸€ä¸ªçº¿ç¨‹è·å–é”ä¹‹åå†å°è¯•è·å–é”æ—¶ä¼šè‡ªåŠ¨è·å–é”ã€‚

åœ¨Javaä¸­ï¼Œé™¤äº†ReentrantLockä»¥å¤–ï¼Œsynchronizedä¹Ÿæ˜¯é‡å…¥é”ã€‚

é‚£ä¹ˆï¼ŒReentrantLockçš„å¯é‡å…¥æ€§æ˜¯æ€ä¹ˆå®ç°çš„å‘¢ï¼Ÿ

## ç»§æ‰¿ä½“ç³»

![qrcode](https://gitee.com/alan-tang-tt/yuan/raw/master/æ­»ç£•%20javaåŒæ­¥ç³»åˆ—/resource/ReentrantLock.png)

ReentrantLockå®ç°äº†Lockæ¥å£ï¼ŒLockæ¥å£é‡Œé¢å®šä¹‰äº†javaä¸­é”åº”è¯¥å®ç°çš„å‡ ä¸ªæ–¹æ³•ï¼š

```java
// è·å–é”
void lock();
// è·å–é”ï¼ˆå¯ä¸­æ–­ï¼‰
void lockInterruptibly() throws InterruptedException;
// å°è¯•è·å–é”ï¼Œå¦‚æœæ²¡è·å–åˆ°é”ï¼Œå°±è¿”å›false
boolean tryLock();
// å°è¯•è·å–é”ï¼Œå¦‚æœæ²¡è·å–åˆ°é”ï¼Œå°±ç­‰å¾…ä¸€æ®µæ—¶é—´ï¼Œè¿™æ®µæ—¶é—´å†…è¿˜æ²¡è·å–åˆ°é”å°±è¿”å›false
boolean tryLock(long time, TimeUnit unit) throws InterruptedException;
// é‡Šæ”¾é”
void unlock();
// æ¡ä»¶é”
Condition newCondition();
```

Lockæ¥å£ä¸­ä¸»è¦å®šä¹‰äº† è·å–é”ã€å°è¯•è·å–é”ã€é‡Šæ”¾é”ã€æ¡ä»¶é”ç­‰å‡ ä¸ªæ–¹æ³•ã€‚

## æºç åˆ†æ

### ä¸»è¦å†…éƒ¨ç±»

ReentrantLockä¸­ä¸»è¦å®šä¹‰äº†ä¸‰ä¸ªå†…éƒ¨ç±»ï¼šSyncã€NonfairSyncã€FairSyncã€‚

```java
abstract static class Sync extends AbstractQueuedSynchronizer {}

static final class NonfairSync extends Sync {}

static final class FairSync extends Sync {}
```

ï¼ˆ1ï¼‰æŠ½è±¡ç±»Syncå®ç°äº†AQSçš„éƒ¨åˆ†æ–¹æ³•ï¼›

ï¼ˆ2ï¼‰NonfairSyncå®ç°äº†Syncï¼Œä¸»è¦ç”¨äºéå…¬å¹³é”çš„è·å–ï¼›

ï¼ˆ3ï¼‰FairSyncå®ç°äº†Syncï¼Œä¸»è¦ç”¨äºå…¬å¹³é”çš„è·å–ã€‚

åœ¨è¿™é‡Œæˆ‘ä»¬å…ˆä¸æ€¥ç€çœ‹æ¯ä¸ªç±»å…·ä½“çš„ä»£ç ï¼Œç­‰ä¸‹é¢å­¦ä¹ å…·ä½“çš„åŠŸèƒ½ç‚¹çš„æ—¶å€™å†æŠŠæ‰€æœ‰æ–¹æ³•ä¸²èµ·æ¥ã€‚

### ä¸»è¦å±æ€§

```java
private final Sync sync;
```

ä¸»è¦å±æ€§å°±ä¸€ä¸ªsyncï¼Œå®ƒåœ¨æ„é€ æ–¹æ³•ä¸­åˆå§‹åŒ–ï¼Œå†³å®šä½¿ç”¨å…¬å¹³é”è¿˜æ˜¯éå…¬å¹³é”çš„æ–¹å¼è·å–é”ã€‚

### ä¸»è¦æ„é€ æ–¹æ³•

```java
// é»˜è®¤æ„é€ æ–¹æ³•
public ReentrantLock() {
    sync = new NonfairSync();
}
// è‡ªå·±å¯é€‰æ‹©ä½¿ç”¨å…¬å¹³é”è¿˜æ˜¯éå…¬å¹³é”
public ReentrantLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();
}
```

ï¼ˆ1ï¼‰é»˜è®¤æ„é€ æ–¹æ³•ä½¿ç”¨çš„æ˜¯éå…¬å¹³é”ï¼›

ï¼ˆ2ï¼‰ç¬¬äºŒä¸ªæ„é€ æ–¹æ³•å¯ä»¥è‡ªå·±å†³å®šä½¿ç”¨å…¬å¹³é”è¿˜æ˜¯éå…¬å¹³é”ï¼›

ä¸Šé¢æˆ‘ä»¬åˆ†æäº†ReentrantLockçš„ä¸»è¦ç»“æ„ï¼Œä¸‹é¢æˆ‘ä»¬è·Ÿç€å‡ ä¸ªä¸»è¦æ–¹æ³•æ¥çœ‹æºç ã€‚

### lock()æ–¹æ³•

å½¤å“¥è´´å¿ƒåœ°åœ¨æ¯ä¸ªæ–¹æ³•çš„æ³¨é‡Šéƒ½åŠ ä¸Šæ–¹æ³•çš„æ¥æºã€‚

#### å…¬å¹³é”

è¿™é‡Œæˆ‘ä»¬å‡è®¾ReentrantLockçš„å®ä¾‹æ˜¯é€šè¿‡ä»¥ä¸‹æ–¹å¼è·å¾—çš„ï¼š

```java
ReentrantLock reentrantLock = new ReentrantLock(true);
```

ä¸‹é¢çš„æ˜¯åŠ é”çš„ä¸»è¦é€»è¾‘ï¼š

```java
// ReentrantLock.lock()
public void lock() {
    // è°ƒç”¨çš„syncå±æ€§çš„lock()æ–¹æ³•
    // è¿™é‡Œçš„syncæ˜¯å…¬å¹³é”ï¼Œæ‰€ä»¥æ˜¯FairSyncçš„å®ä¾‹
    sync.lock();
}
// ReentrantLock.FairSync.lock()
final void lock() {
    // è°ƒç”¨AQSçš„acquire()æ–¹æ³•è·å–é”
    // æ³¨æ„ï¼Œè¿™é‡Œä¼ çš„å€¼ä¸º1
    acquire(1);
}
// AbstractQueuedSynchronizer.acquire()
public final void acquire(int arg) {
    // å°è¯•è·å–é”
    // å¦‚æœå¤±è´¥äº†ï¼Œå°±æ’é˜Ÿ
    if (!tryAcquire(arg) &&
        // æ³¨æ„addWaiter()è¿™é‡Œä¼ å…¥çš„èŠ‚ç‚¹æ¨¡å¼ä¸ºç‹¬å æ¨¡å¼
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
// ReentrantLock.FairSync.tryAcquire()
protected final boolean tryAcquire(int acquires) {
    // å½“å‰çº¿ç¨‹
    final Thread current = Thread.currentThread();
    // æŸ¥çœ‹å½“å‰çŠ¶æ€å˜é‡çš„å€¼
    int c = getState();
    // å¦‚æœçŠ¶æ€å˜é‡çš„å€¼ä¸º0ï¼Œè¯´æ˜æš‚æ—¶è¿˜æ²¡æœ‰äººå æœ‰é”
    if (c == 0) {
        // å¦‚æœæ²¡æœ‰å…¶å®ƒçº¿ç¨‹åœ¨æ’é˜Ÿï¼Œé‚£ä¹ˆå½“å‰çº¿ç¨‹å°è¯•æ›´æ–°stateçš„å€¼ä¸º1
        // å¦‚æœæˆåŠŸäº†ï¼Œåˆ™è¯´æ˜å½“å‰çº¿ç¨‹è·å–äº†é”
        if (!hasQueuedPredecessors() &&
            compareAndSetState(0, acquires)) {
            // å½“å‰çº¿ç¨‹è·å–äº†é”ï¼ŒæŠŠè‡ªå·±è®¾ç½®åˆ°exclusiveOwnerThreadå˜é‡ä¸­
            // exclusiveOwnerThreadæ˜¯AQSçš„çˆ¶ç±»AbstractOwnableSynchronizerä¸­æä¾›çš„å˜é‡
            setExclusiveOwnerThread(current);
            // è¿”å›trueè¯´æ˜æˆåŠŸè·å–äº†é”
            return true;
        }
    }
    // å¦‚æœå½“å‰çº¿ç¨‹æœ¬èº«å°±å æœ‰ç€é”ï¼Œç°åœ¨åˆå°è¯•è·å–é”
    // é‚£ä¹ˆï¼Œç›´æ¥è®©å®ƒè·å–é”å¹¶è¿”å›true
    else if (current == getExclusiveOwnerThread()) {
        // çŠ¶æ€å˜é‡stateçš„å€¼åŠ 1
        int nextc = c + acquires;
        // å¦‚æœæº¢å‡ºäº†ï¼Œåˆ™æŠ¥é”™
        if (nextc < 0)
            throw new Error("Maximum lock count exceeded");
        // è®¾ç½®åˆ°stateä¸­
        // è¿™é‡Œä¸éœ€è¦CASæ›´æ–°state
        // å› ä¸ºå½“å‰çº¿ç¨‹å æœ‰ç€é”ï¼Œå…¶å®ƒçº¿ç¨‹åªä¼šCASæŠŠstateä»0æ›´æ–°æˆ1ï¼Œæ˜¯ä¸ä¼šæˆåŠŸçš„
        // æ‰€ä»¥ä¸å­˜åœ¨ç«äº‰ï¼Œè‡ªç„¶ä¸éœ€è¦ä½¿ç”¨CASæ¥æ›´æ–°
        setState(nextc);
        // å½“çº¿ç¨‹è·å–é”æˆåŠŸ
        return true;
    }
    // å½“å‰çº¿ç¨‹å°è¯•è·å–é”å¤±è´¥
    return false;
}
// AbstractQueuedSynchronizer.addWaiter()
// è°ƒç”¨è¿™ä¸ªæ–¹æ³•ï¼Œè¯´æ˜ä¸Šé¢å°è¯•è·å–é”å¤±è´¥äº†
private Node addWaiter(Node mode) {
    // æ–°å»ºä¸€ä¸ªèŠ‚ç‚¹
    Node node = new Node(Thread.currentThread(), mode);
    // è¿™é‡Œå…ˆå°è¯•æŠŠæ–°èŠ‚ç‚¹åŠ åˆ°å°¾èŠ‚ç‚¹åé¢
    // å¦‚æœæˆåŠŸäº†å°±è¿”å›æ–°èŠ‚ç‚¹
    // å¦‚æœæ²¡æˆåŠŸå†è°ƒç”¨enq()æ–¹æ³•ä¸æ–­å°è¯•
    Node pred = tail;
    // å¦‚æœå°¾èŠ‚ç‚¹ä¸ä¸ºç©º
    if (pred != null) {
        // è®¾ç½®æ–°èŠ‚ç‚¹çš„å‰ç½®èŠ‚ç‚¹ä¸ºç°åœ¨çš„å°¾èŠ‚ç‚¹
        node.prev = pred;
        // CASæ›´æ–°å°¾èŠ‚ç‚¹ä¸ºæ–°èŠ‚ç‚¹
        if (compareAndSetTail(pred, node)) {
            // å¦‚æœæˆåŠŸäº†ï¼ŒæŠŠæ—§å°¾èŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹æŒ‡å‘æ–°èŠ‚ç‚¹
            pred.next = node;
            // å¹¶è¿”å›æ–°èŠ‚ç‚¹
            return node;
        }
    }
    // å¦‚æœä¸Šé¢å°è¯•å…¥é˜Ÿæ–°èŠ‚ç‚¹æ²¡æˆåŠŸï¼Œè°ƒç”¨enq()å¤„ç†
    enq(node);
    return node;
}
// AbstractQueuedSynchronizer.enq()
private Node enq(final Node node) {
    // è‡ªæ—‹ï¼Œä¸æ–­å°è¯•
    for (;;) {
        Node t = tail;
        // å¦‚æœå°¾èŠ‚ç‚¹ä¸ºç©ºï¼Œè¯´æ˜è¿˜æœªåˆå§‹åŒ–
        if (t == null) { // Must initialize
            // åˆå§‹åŒ–å¤´èŠ‚ç‚¹å’Œå°¾èŠ‚ç‚¹
            if (compareAndSetHead(new Node()))
                tail = head;
        } else {
            // å¦‚æœå°¾èŠ‚ç‚¹ä¸ä¸ºç©º
            // è®¾ç½®æ–°èŠ‚ç‚¹çš„å‰ä¸€ä¸ªèŠ‚ç‚¹ä¸ºç°åœ¨çš„å°¾èŠ‚ç‚¹
            node.prev = t;
            // CASæ›´æ–°å°¾èŠ‚ç‚¹ä¸ºæ–°èŠ‚ç‚¹
            if (compareAndSetTail(t, node)) {
                // æˆåŠŸäº†ï¼Œåˆ™è®¾ç½®æ—§å°¾èŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ä¸ºæ–°èŠ‚ç‚¹
                t.next = node;
                // å¹¶è¿”å›æ—§å°¾èŠ‚ç‚¹
                return t;
            }
        }
    }
}
// AbstractQueuedSynchronizer.acquireQueued()
// è°ƒç”¨ä¸Šé¢çš„addWaiter()æ–¹æ³•ä½¿å¾—æ–°èŠ‚ç‚¹å·²ç»æˆåŠŸå…¥é˜Ÿäº†
// è¿™ä¸ªæ–¹æ³•æ˜¯å°è¯•è®©å½“å‰èŠ‚ç‚¹æ¥è·å–é”çš„
final boolean acquireQueued(final Node node, int arg) {
    // å¤±è´¥æ ‡è®°
    boolean failed = true;
    try {
        // ä¸­æ–­æ ‡è®°
        boolean interrupted = false;
        // è‡ªæ—‹
        for (;;) {
            // å½“å‰èŠ‚ç‚¹çš„å‰ä¸€ä¸ªèŠ‚ç‚¹
            final Node p = node.predecessor();
            // å¦‚æœå½“å‰èŠ‚ç‚¹çš„å‰ä¸€ä¸ªèŠ‚ç‚¹ä¸ºheadèŠ‚ç‚¹ï¼Œåˆ™è¯´æ˜è½®åˆ°è‡ªå·±è·å–é”äº†
            // è°ƒç”¨ReentrantLock.FairSync.tryAcquire()æ–¹æ³•å†æ¬¡å°è¯•è·å–é”
            if (p == head && tryAcquire(arg)) {
                // å°è¯•è·å–é”æˆåŠŸ
                // è¿™é‡ŒåŒæ—¶åªä¼šæœ‰ä¸€ä¸ªçº¿ç¨‹åœ¨æ‰§è¡Œï¼Œæ‰€ä»¥ä¸éœ€è¦ç”¨CASæ›´æ–°
                // æŠŠå½“å‰èŠ‚ç‚¹è®¾ç½®ä¸ºæ–°çš„å¤´èŠ‚ç‚¹
                setHead(node);
                // å¹¶æŠŠä¸Šä¸€ä¸ªèŠ‚ç‚¹ä»é“¾è¡¨ä¸­åˆ é™¤
                p.next = null; // help GC
                // æœªå¤±è´¥
                failed = false;
                return interrupted;
            }
            // æ˜¯å¦éœ€è¦é˜»å¡
            if (shouldParkAfterFailedAcquire(p, node) &&
                // çœŸæ­£é˜»å¡çš„æ–¹æ³•
                parkAndCheckInterrupt())
                // å¦‚æœä¸­æ–­äº†
                interrupted = true;
        }
    } finally {
        // å¦‚æœå¤±è´¥äº†
        if (failed)
            // å–æ¶ˆè·å–é”
            cancelAcquire(node);
    }
}
// AbstractQueuedSynchronizer.shouldParkAfterFailedAcquire()
// è¿™ä¸ªæ–¹æ³•æ˜¯åœ¨ä¸Šé¢çš„for()å¾ªç¯é‡Œé¢è°ƒç”¨çš„
// ç¬¬ä¸€æ¬¡è°ƒç”¨ä¼šæŠŠå‰ä¸€ä¸ªèŠ‚ç‚¹çš„ç­‰å¾…çŠ¶æ€è®¾ç½®ä¸ºSIGNALï¼Œå¹¶è¿”å›false
// ç¬¬äºŒæ¬¡è°ƒç”¨æ‰ä¼šè¿”å›true
private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
    // ä¸Šä¸€ä¸ªèŠ‚ç‚¹çš„ç­‰å¾…çŠ¶æ€
    // æ³¨æ„Nodeçš„waitStatuså­—æ®µæˆ‘ä»¬åœ¨ä¸Šé¢åˆ›å»ºNodeçš„æ—¶å€™å¹¶æ²¡æœ‰æŒ‡å®š
    // ä¹Ÿå°±æ˜¯è¯´ä½¿ç”¨çš„æ˜¯é»˜è®¤å€¼0
    // è¿™é‡ŒæŠŠå„ç§ç­‰å¾…çŠ¶æ€å†è´´å‡ºæ¥
    //static final int CANCELLED =  1;
    //static final int SIGNAL    = -1;
    //static final int CONDITION = -2;
    //static final int PROPAGATE = -3;
    int ws = pred.waitStatus;
    // å¦‚æœç­‰å¾…çŠ¶æ€ä¸ºSIGNAL(ç­‰å¾…å”¤é†’)ï¼Œç›´æ¥è¿”å›true
    if (ws == Node.SIGNAL)
        return true;
    // å¦‚æœå‰ä¸€ä¸ªèŠ‚ç‚¹çš„çŠ¶æ€å¤§äº0ï¼Œä¹Ÿå°±æ˜¯å·²å–æ¶ˆçŠ¶æ€
    if (ws > 0) {
        // æŠŠå‰é¢æ‰€æœ‰å–æ¶ˆçŠ¶æ€çš„èŠ‚ç‚¹éƒ½ä»é“¾è¡¨ä¸­åˆ é™¤
        do {
            node.prev = pred = pred.prev;
        } while (pred.waitStatus > 0);
        pred.next = node;
    } else {
        // å¦‚æœå‰ä¸€ä¸ªèŠ‚ç‚¹çš„çŠ¶æ€å°äºç­‰äº0ï¼Œåˆ™æŠŠå…¶çŠ¶æ€è®¾ç½®ä¸ºç­‰å¾…å”¤é†’
        // è¿™é‡Œå¯ä»¥ç®€å•åœ°ç†è§£ä¸ºæŠŠåˆå§‹çŠ¶æ€0è®¾ç½®ä¸ºSIGNAL
        // CONDITIONæ˜¯æ¡ä»¶é”çš„æ—¶å€™ä½¿ç”¨çš„
        // PROPAGATEæ˜¯å…±äº«é”ä½¿ç”¨çš„
        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
    }
    return false;
}
// AbstractQueuedSynchronizer.parkAndCheckInterrupt()
private final boolean parkAndCheckInterrupt() {
    // é˜»å¡å½“å‰çº¿ç¨‹
    // åº•å±‚è°ƒç”¨çš„æ˜¯Unsafeçš„park()æ–¹æ³•
    LockSupport.park(this);
    // è¿”å›æ˜¯å¦å·²ä¸­æ–­
    return Thread.interrupted();
}
```

çœ‹è¿‡ä¹‹å‰å½¤å“¥å†™çš„ã€[æ­»ç£• javaåŒæ­¥ç³»åˆ—ä¹‹è‡ªå·±åŠ¨æ‰‹å†™ä¸€ä¸ªé”Lock](https://mp.weixin.qq.com/s/1RU5jh7UcXGtKlae8tusVA)ã€‘çš„åŒå­¦çœ‹ä»Šå¤©è¿™ä¸ªåŠ é”è¿‡ç¨‹åº”è¯¥æ€è·¯ä¼šæ¯”è¾ƒæ¸…æ™°ã€‚

ä¸‹é¢æˆ‘ä»¬çœ‹ä¸€ä¸‹ä¸»è¦æ–¹æ³•çš„è°ƒç”¨å…³ç³»ï¼Œå¯ä»¥è·Ÿç€æˆ‘çš„ â†’ å±‚çº§åœ¨è„‘æµ·ä¸­å¤§æ¦‚è¿‡ä¸€éæ¯ä¸ªæ–¹æ³•çš„ä¸»è¦ä»£ç ï¼š

```java
ReentrantLock#lock()
->ReentrantLock.FairSync#lock() // å…¬å¹³æ¨¡å¼è·å–é”
  ->AbstractQueuedSynchronizer#acquire() // AQSçš„è·å–é”æ–¹æ³•
    ->ReentrantLock.FairSync#tryAcquire() // å°è¯•è·å–é”
    ->AbstractQueuedSynchronizer#addWaiter()  // æ·»åŠ åˆ°é˜Ÿåˆ—
	  ->AbstractQueuedSynchronizer#enq()  // å…¥é˜Ÿ
    ->AbstractQueuedSynchronizer#acquireQueued() // é‡Œé¢æœ‰ä¸ªfor()å¾ªç¯ï¼Œå”¤é†’åå†æ¬¡å°è¯•è·å–é”
      ->AbstractQueuedSynchronizer#shouldParkAfterFailedAcquire() // æ£€æŸ¥æ˜¯å¦è¦é˜»å¡
      ->AbstractQueuedSynchronizer#parkAndCheckInterrupt()  // çœŸæ­£é˜»å¡çš„åœ°æ–¹
```

è·å–é”çš„ä¸»è¦è¿‡ç¨‹å¤§è‡´å¦‚ä¸‹ï¼š

ï¼ˆ1ï¼‰å°è¯•è·å–é”ï¼Œå¦‚æœè·å–åˆ°äº†å°±ç›´æ¥è¿”å›äº†ï¼›

ï¼ˆ2ï¼‰å°è¯•è·å–é”å¤±è´¥ï¼Œå†è°ƒç”¨addWaiter()æ„å»ºæ–°èŠ‚ç‚¹å¹¶æŠŠæ–°èŠ‚ç‚¹å…¥é˜Ÿï¼›

ï¼ˆ3ï¼‰ç„¶åè°ƒç”¨acquireQueued()å†æ¬¡å°è¯•è·å–é”ï¼Œå¦‚æœæˆåŠŸäº†ï¼Œç›´æ¥è¿”å›ï¼›

ï¼ˆ4ï¼‰å¦‚æœå†æ¬¡å¤±è´¥ï¼Œå†è°ƒç”¨shouldParkAfterFailedAcquire()å°†èŠ‚ç‚¹çš„ç­‰å¾…çŠ¶æ€ç½®ä¸ºç­‰å¾…å”¤é†’ï¼ˆSIGNALï¼‰ï¼›

ï¼ˆ5ï¼‰è°ƒç”¨parkAndCheckInterrupt()é˜»å¡å½“å‰çº¿ç¨‹ï¼›

ï¼ˆ6ï¼‰å¦‚æœè¢«å”¤é†’äº†ï¼Œä¼šç»§ç»­åœ¨acquireQueued()çš„for()å¾ªç¯å†æ¬¡å°è¯•è·å–é”ï¼Œå¦‚æœæˆåŠŸäº†å°±è¿”å›ï¼›

ï¼ˆ7ï¼‰å¦‚æœä¸æˆåŠŸï¼Œå†æ¬¡é˜»å¡ï¼Œé‡å¤ï¼ˆ3ï¼‰ï¼ˆ4ï¼‰ï¼ˆ5ï¼‰ç›´åˆ°æˆåŠŸè·å–åˆ°é”ã€‚

ä»¥ä¸Šå°±æ˜¯æ•´ä¸ªå…¬å¹³é”è·å–é”çš„è¿‡ç¨‹ï¼Œä¸‹é¢æˆ‘ä»¬çœ‹çœ‹éå…¬å¹³é”æ˜¯æ€ä¹ˆè·å–é”çš„ã€‚

#### éå…¬å¹³é”

```java
// ReentrantLock.lock()
public void lock() {
    sync.lock();
}
// ReentrantLock.NonfairSync.lock()
// è¿™ä¸ªæ–¹æ³•åœ¨å…¬å¹³é”æ¨¡å¼ä¸‹æ˜¯ç›´æ¥è°ƒç”¨çš„acquire(1);
final void lock() {
    // ç›´æ¥å°è¯•CASæ›´æ–°çŠ¶æ€å˜é‡
    if (compareAndSetState(0, 1))
        // å¦‚æœæ›´æ–°æˆåŠŸï¼Œè¯´æ˜è·å–åˆ°é”ï¼ŒæŠŠå½“å‰çº¿ç¨‹è®¾ä¸ºç‹¬å çº¿ç¨‹
        setExclusiveOwnerThread(Thread.currentThread());
    else
        acquire(1);
}
// ReentrantLock.NonfairSync.tryAcquire()
protected final boolean tryAcquire(int acquires) {
    // è°ƒç”¨çˆ¶ç±»çš„æ–¹æ³•
    return nonfairTryAcquire(acquires);
}
// ReentrantLock.Sync.nonfairTryAcquire()
final boolean nonfairTryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    if (c == 0) {
        // å¦‚æœçŠ¶æ€å˜é‡çš„å€¼ä¸º0ï¼Œå†æ¬¡å°è¯•CASæ›´æ–°çŠ¶æ€å˜é‡çš„å€¼
        // ç›¸å¯¹äºå…¬å¹³é”æ¨¡å¼å°‘äº†!hasQueuedPredecessors()æ¡ä»¶
        if (compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        if (nextc < 0) // overflow
            throw new Error("Maximum lock count exceeded");
        setState(nextc);
        return true;
    }
    return false;
}
```

ç›¸å¯¹äºå…¬å¹³é”ï¼Œéå…¬å¹³é”åŠ é”çš„è¿‡ç¨‹ä¸»è¦æœ‰ä¸¤ç‚¹ä¸åŒï¼š

ï¼ˆ1ï¼‰ä¸€å¼€å§‹å°±å°è¯•CASæ›´æ–°çŠ¶æ€å˜é‡stateçš„å€¼ï¼Œå¦‚æœæˆåŠŸäº†å°±è·å–åˆ°é”äº†ï¼›

ï¼ˆ2ï¼‰åœ¨tryAcquire()çš„æ—¶å€™æ²¡æœ‰æ£€æŸ¥æ˜¯å¦å‰é¢æœ‰æ’é˜Ÿçš„çº¿ç¨‹ï¼Œç›´æ¥ä¸Šå»è·å–é”æ‰ä¸ç®¡åˆ«äººæœ‰æ²¡æœ‰æ’é˜Ÿå‘¢ï¼›

æ€»çš„æ¥è¯´ï¼Œç›¸å¯¹äºå…¬å¹³é”ï¼Œéå…¬å¹³é”åœ¨ä¸€å¼€å§‹å°±å¤šäº†ä¸¤æ¬¡ç›´æ¥å°è¯•è·å–é”çš„è¿‡ç¨‹ã€‚

### lockInterruptibly()æ–¹æ³•

æ”¯æŒçº¿ç¨‹ä¸­æ–­ï¼Œå®ƒä¸lock()æ–¹æ³•çš„ä¸»è¦åŒºåˆ«åœ¨äºlockInterruptibly()è·å–é”çš„æ—¶å€™å¦‚æœçº¿ç¨‹ä¸­æ–­äº†ï¼Œä¼šæŠ›å‡ºä¸€ä¸ªå¼‚å¸¸ï¼Œè€Œlock()ä¸ä¼šç®¡çº¿ç¨‹æ˜¯å¦ä¸­æ–­éƒ½ä¼šä¸€ç›´å°è¯•è·å–é”ï¼Œè·å–é”ä¹‹åæŠŠè‡ªå·±æ ‡è®°ä¸ºå·²ä¸­æ–­ï¼Œç»§ç»­æ‰§è¡Œè‡ªå·±çš„é€»è¾‘ï¼Œåé¢ä¹Ÿä¼šæ­£å¸¸é‡Šæ”¾é”ã€‚

é¢˜å¤–è¯ï¼š

çº¿ç¨‹ä¸­æ–­ï¼Œåªæ˜¯åœ¨çº¿ç¨‹ä¸Šæ‰“ä¸€ä¸ªä¸­æ–­æ ‡å¿—ï¼Œå¹¶ä¸ä¼šå¯¹è¿è¡Œä¸­çš„çº¿ç¨‹æœ‰ä»€ä¹ˆå½±å“ï¼Œå…·ä½“éœ€è¦æ ¹æ®è¿™ä¸ªä¸­æ–­æ ‡å¿—å¹²äº›ä»€ä¹ˆï¼Œç”¨æˆ·è‡ªå·±å»å†³å®šã€‚

æ¯”å¦‚ï¼Œå¦‚æœç”¨æˆ·åœ¨è°ƒç”¨lock()è·å–é”åï¼Œå‘ç°çº¿ç¨‹ä¸­æ–­äº†ï¼Œå°±ç›´æ¥è¿”å›äº†ï¼Œè€Œå¯¼è‡´æ²¡æœ‰é‡Šæ”¾é”ï¼Œè¿™ä¹Ÿæ˜¯å…è®¸çš„ï¼Œä½†æ˜¯ä¼šå¯¼è‡´è¿™ä¸ªé”ä¸€ç›´å¾—ä¸åˆ°é‡Šæ”¾ï¼Œå°±å‡ºç°äº†æ­»é”ã€‚

```java
lock.lock();

if (Thread.currentThread().interrupted()) {
    return ;
}

lock.unlock();
```

å½“ç„¶ï¼Œè¿™é‡Œåªæ˜¯ä¸¾ä¸ªä¾‹å­ï¼Œå®é™…ä½¿ç”¨è‚¯å®šæ˜¯è¦æŠŠlock.lock()åé¢çš„ä»£ç éƒ½æ”¾åœ¨try...finally...é‡Œé¢çš„ä»¥ä¿è¯é”å§‹ç»ˆä¼šé‡Šæ”¾ï¼Œè¿™é‡Œä¸»è¦æ˜¯ä¸ºäº†è¯´æ˜çº¿ç¨‹ä¸­æ–­åªæ˜¯ä¸€ä¸ªæ ‡å¿—ï¼Œè‡³äºè¦åšä»€ä¹ˆå®Œå…¨ç”±ç”¨æˆ·è‡ªå·±å†³å®šã€‚

### tryLock()æ–¹æ³•

å°è¯•è·å–ä¸€æ¬¡é”ï¼ŒæˆåŠŸäº†å°±è¿”å›trueï¼Œæ²¡æˆåŠŸå°±è¿”å›falseï¼Œä¸ä¼šç»§ç»­å°è¯•ã€‚

```java
// ReentrantLock.tryLock()
public boolean tryLock() {
    // ç›´æ¥è°ƒç”¨Syncçš„nonfairTryAcquire()æ–¹æ³•
    return sync.nonfairTryAcquire(1);
}
// ReentrantLock.Sync.nonfairTryAcquire()
final boolean nonfairTryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    if (c == 0) {
        if (compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        if (nextc < 0) // overflow
            throw new Error("Maximum lock count exceeded");
        setState(nextc);
        return true;
    }
    return false;
}
```

tryLock()æ–¹æ³•æ¯”è¾ƒç®€å•ï¼Œç›´æ¥ä»¥éå…¬å¹³çš„æ¨¡å¼å»å°è¯•è·å–ä¸€æ¬¡é”ï¼Œè·å–åˆ°äº†æˆ–è€…é”æœ¬æ¥å°±æ˜¯å½“å‰çº¿ç¨‹å æœ‰ç€å°±è¿”å›trueï¼Œå¦åˆ™è¿”å›falseã€‚

### tryLock(long time, TimeUnit unit)æ–¹æ³•

å°è¯•è·å–é”ï¼Œå¹¶ç­‰å¾…ä¸€æ®µæ—¶é—´ï¼Œå¦‚æœåœ¨è¿™æ®µæ—¶é—´å†…éƒ½æ²¡æœ‰è·å–åˆ°é”ï¼Œå°±è¿”å›falseã€‚

```java
// ReentrantLock.tryLock()
public boolean tryLock(long timeout, TimeUnit unit)
        throws InterruptedException {
    // è°ƒç”¨AQSä¸­çš„æ–¹æ³•
    return sync.tryAcquireNanos(1, unit.toNanos(timeout));
}
// AbstractQueuedSynchronizer.tryAcquireNanos()
public final boolean tryAcquireNanos(int arg, long nanosTimeout)
        throws InterruptedException {
    // å¦‚æœçº¿ç¨‹ä¸­æ–­äº†ï¼ŒæŠ›å‡ºå¼‚å¸¸
    if (Thread.interrupted())
        throw new InterruptedException();
    // å…ˆå°è¯•è·å–ä¸€æ¬¡é”
    return tryAcquire(arg) ||
        doAcquireNanos(arg, nanosTimeout);
}
// AbstractQueuedSynchronizer.doAcquireNanos()
private boolean doAcquireNanos(int arg, long nanosTimeout)
        throws InterruptedException {
    // å¦‚æœæ—¶é—´å·²ç»åˆ°æœŸäº†ï¼Œç›´æ¥è¿”å›false
    if (nanosTimeout <= 0L)
        return false;
    // åˆ°æœŸæ—¶é—´
    final long deadline = System.nanoTime() + nanosTimeout;
    final Node node = addWaiter(Node.EXCLUSIVE);
    boolean failed = true;
    try {
        for (;;) {
            final Node p = node.predecessor();
            if (p == head && tryAcquire(arg)) {
                setHead(node);
                p.next = null; // help GC
                failed = false;
                return true;
            }
            nanosTimeout = deadline - System.nanoTime();
            // å¦‚æœåˆ°æœŸäº†ï¼Œå°±ç›´æ¥è¿”å›false
            if (nanosTimeout <= 0L)
                return false;
            // spinForTimeoutThreshold = 1000L;
            // åªæœ‰åˆ°æœŸæ—¶é—´å¤§äº1000çº³ç§’ï¼Œæ‰é˜»å¡
            // å°äºç­‰äº1000çº³ç§’ï¼Œç›´æ¥è‡ªæ—‹è§£å†³å°±å¾—äº†
            if (shouldParkAfterFailedAcquire(p, node) &&
                nanosTimeout > spinForTimeoutThreshold)
                // é˜»å¡ä¸€æ®µæ—¶é—´
                LockSupport.parkNanos(this, nanosTimeout);
            if (Thread.interrupted())
                throw new InterruptedException();
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
```

tryLock(long time, TimeUnit unit)æ–¹æ³•åœ¨é˜»å¡çš„æ—¶å€™åŠ ä¸Šé˜»å¡æ—¶é—´ï¼Œå¹¶ä¸”ä¼šéšæ—¶æ£€æŸ¥æ˜¯å¦åˆ°æœŸï¼Œåªè¦åˆ°æœŸäº†æ²¡è·å–åˆ°é”å°±è¿”å›falseã€‚

### unlock()æ–¹æ³•

é‡Šæ”¾é”ã€‚

```java
// java.util.concurrent.locks.ReentrantLock.unlock()
public void unlock() {
    sync.release(1);
}
// java.util.concurrent.locks.AbstractQueuedSynchronizer.release
public final boolean release(int arg) {
    // è°ƒç”¨AQSå®ç°ç±»çš„tryRelease()æ–¹æ³•é‡Šæ”¾é”
    if (tryRelease(arg)) {
        Node h = head;
        // å¦‚æœå¤´èŠ‚ç‚¹ä¸ä¸ºç©ºï¼Œä¸”ç­‰å¾…çŠ¶æ€ä¸æ˜¯0ï¼Œå°±å”¤é†’ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
        // è¿˜è®°å¾—waitStatuså—ï¼Ÿ
        // åœ¨æ¯ä¸ªèŠ‚ç‚¹é˜»å¡ä¹‹å‰ä¼šæŠŠå…¶ä¸Šä¸€ä¸ªèŠ‚ç‚¹çš„ç­‰å¾…çŠ¶æ€è®¾ä¸ºSIGNALï¼ˆ-1ï¼‰
        // æ‰€ä»¥ï¼ŒSIGNALçš„å‡†ç¡®ç†è§£åº”è¯¥æ˜¯å”¤é†’ä¸‹ä¸€ä¸ªç­‰å¾…çš„çº¿ç¨‹
        if (h != null && h.waitStatus != 0)
            unparkSuccessor(h);
        return true;
    }
    return false;
}
// java.util.concurrent.locks.ReentrantLock.Sync.tryRelease
protected final boolean tryRelease(int releases) {
    int c = getState() - releases;
    // å¦‚æœå½“å‰çº¿ç¨‹ä¸æ˜¯å æœ‰ç€é”çš„çº¿ç¨‹ï¼ŒæŠ›å‡ºå¼‚å¸¸
    if (Thread.currentThread() != getExclusiveOwnerThread())
        throw new IllegalMonitorStateException();
    boolean free = false;
    // å¦‚æœçŠ¶æ€å˜é‡çš„å€¼ä¸º0äº†ï¼Œè¯´æ˜å®Œå…¨é‡Šæ”¾äº†é”
    // è¿™ä¹Ÿå°±æ˜¯ä¸ºä»€ä¹ˆé‡å…¥é”è°ƒç”¨äº†å¤šå°‘æ¬¡lock()å°±è¦è°ƒç”¨å¤šå°‘æ¬¡unlock()çš„åŸå› 
    // å¦‚æœä¸è¿™æ ·åšï¼Œä¼šå¯¼è‡´é”ä¸ä¼šå®Œå…¨é‡Šæ”¾ï¼Œåˆ«çš„çº¿ç¨‹æ°¸è¿œæ— æ³•è·å–åˆ°é”
    if (c == 0) {
        free = true;
        // æ¸…ç©ºå æœ‰çº¿ç¨‹
        setExclusiveOwnerThread(null);
    }
    // è®¾ç½®çŠ¶æ€å˜é‡çš„å€¼
    setState(c);
    return free;
}
private void unparkSuccessor(Node node) {
    // æ³¨æ„ï¼Œè¿™é‡Œçš„nodeæ˜¯å¤´èŠ‚ç‚¹
    
    // å¦‚æœå¤´èŠ‚ç‚¹çš„ç­‰å¾…çŠ¶æ€å°äº0ï¼Œå°±æŠŠå®ƒè®¾ç½®ä¸º0
    int ws = node.waitStatus;
    if (ws < 0)
        compareAndSetWaitStatus(node, ws, 0);

    // å¤´èŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
    Node s = node.next;
    // å¦‚æœä¸‹ä¸€ä¸ªèŠ‚ç‚¹ä¸ºç©ºï¼Œæˆ–è€…å…¶ç­‰å¾…çŠ¶æ€å¤§äº0ï¼ˆå®é™…ä¸ºå·²å–æ¶ˆï¼‰
    if (s == null || s.waitStatus > 0) {
        s = null;
        // ä»å°¾èŠ‚ç‚¹å‘å‰éå†å–åˆ°é˜Ÿåˆ—æœ€å‰é¢çš„é‚£ä¸ªçŠ¶æ€ä¸æ˜¯å·²å–æ¶ˆçŠ¶æ€çš„èŠ‚ç‚¹
        for (Node t = tail; t != null && t != node; t = t.prev)
            if (t.waitStatus <= 0)
                s = t;
    }
    // å¦‚æœä¸‹ä¸€ä¸ªèŠ‚ç‚¹ä¸ä¸ºç©ºï¼Œåˆ™å”¤é†’å®ƒ
    if (s != null)
        LockSupport.unpark(s.thread);
}
```

é‡Šæ”¾é”çš„è¿‡ç¨‹å¤§è‡´ä¸ºï¼š

ï¼ˆ1ï¼‰å°†stateçš„å€¼å‡1ï¼›

ï¼ˆ2ï¼‰å¦‚æœstateå‡åˆ°äº†0ï¼Œè¯´æ˜å·²ç»å®Œå…¨é‡Šæ”¾é”äº†ï¼Œå”¤é†’ä¸‹ä¸€ä¸ªç­‰å¾…ç€çš„èŠ‚ç‚¹ï¼›


**æœªå®Œå¾…ç»­ï¼Œä¸‹ä¸€ç« æˆ‘ä»¬ç»§ç»­å­¦ä¹ ReentrantLockä¸­å…³äºæ¡ä»¶é”çš„éƒ¨åˆ†**

## å½©è›‹

ä¸ºä»€ä¹ˆReentrantLocké»˜è®¤é‡‡ç”¨çš„æ˜¯éå…¬å¹³æ¨¡å¼ï¼Ÿ

ç­”ï¼šå› ä¸ºéå…¬å¹³æ¨¡å¼æ•ˆç‡æ¯”è¾ƒé«˜ã€‚

ä¸ºä»€ä¹ˆéå…¬å¹³æ¨¡å¼æ•ˆç‡æ¯”è¾ƒé«˜ï¼Ÿ

ç­”ï¼šå› ä¸ºéå…¬å¹³æ¨¡å¼ä¼šåœ¨ä¸€å¼€å§‹å°±å°è¯•ä¸¤æ¬¡è·å–é”ï¼Œå¦‚æœå½“æ—¶æ­£å¥½stateçš„å€¼ä¸º0ï¼Œå®ƒå°±ä¼šæˆåŠŸè·å–åˆ°é”ï¼Œå°‘äº†æ’é˜Ÿå¯¼è‡´çš„é˜»å¡/å”¤é†’è¿‡ç¨‹ï¼Œå¹¶ä¸”å‡å°‘äº†çº¿ç¨‹é¢‘ç¹çš„åˆ‡æ¢å¸¦æ¥çš„æ€§èƒ½æŸè€—ã€‚

éå…¬å¹³æ¨¡å¼æœ‰ä»€ä¹ˆå¼Šç«¯ï¼Ÿ

ç­”ï¼šéå…¬å¹³æ¨¡å¼æœ‰å¯èƒ½ä¼šå¯¼è‡´ä¸€å¼€å§‹æ’é˜Ÿçš„çº¿ç¨‹ä¸€ç›´è·å–ä¸åˆ°é”ï¼Œå¯¼è‡´çº¿ç¨‹é¥¿æ­»ã€‚

## æ¨èé˜…è¯»

1. [æ­»ç£• javaåŒæ­¥ç³»åˆ—ä¹‹AQSèµ·ç¯‡](https://mp.weixin.qq.com/s/nAqgec8GscULz6DkkYFINg)

2. [æ­»ç£• javaåŒæ­¥ç³»åˆ—ä¹‹è‡ªå·±åŠ¨æ‰‹å†™ä¸€ä¸ªé”Lock](https://mp.weixin.qq.com/s/1RU5jh7UcXGtKlae8tusVA)

3. [æ­»ç£• javaé­”æ³•ç±»ä¹‹Unsafeè§£æ](https://mp.weixin.qq.com/s/0s-u-MysppIaIHVrshp9fA)

4. [æ­»ç£• javaåŒæ­¥ç³»åˆ—ä¹‹JMMï¼ˆJava Memory Modelï¼‰](https://mp.weixin.qq.com/s/jownTN--npu3o8B4c3sbeA)

5. [æ­»ç£• javaåŒæ­¥ç³»åˆ—ä¹‹volatileè§£æ](https://mp.weixin.qq.com/s/TROZ4BhcDImwHvhAl_I_6w)

6. [æ­»ç£• javaåŒæ­¥ç³»åˆ—ä¹‹synchronizedè§£æ](https://mp.weixin.qq.com/s/RT7VreIh9PU03HhE3WSLjg)

---

æ¬¢è¿å…³æ³¨æˆ‘çš„å…¬ä¼—å·â€œå½¤å“¥è¯»æºç â€ï¼ŒæŸ¥çœ‹æ›´å¤šæºç ç³»åˆ—æ–‡ç« , ä¸å½¤å“¥ä¸€èµ·ç•…æ¸¸æºç çš„æµ·æ´‹ã€‚

![qrcode](https://gitee.com/alan-tang-tt/yuan/raw/master/æ­»ç£•%20javaé›†åˆç³»åˆ—/resource/qrcode_ss.jpg)
