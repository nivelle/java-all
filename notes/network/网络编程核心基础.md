### ip地址及其分类
[![rIOckD.png](https://s3.ax1x.com/2020/12/28/rIOckD.png)](https://imgchr.com/i/rIOckD)

- 每个ip地址均包含两个标识码，网络号和主机号。同一个物理网络中的所有主机使用同一个网络号，而这个网络中的各个主机(如工作站，服务器，路由器)都有一个局域网内位移的主机号与之对应。 因此IP地址的格式表示为：IP地址 = {<网络号>,<主机号>}

- 各种网络差异很大，有的网络中有很多主机，而有的网络中主机很少。把ip地址划分为不同的类别就是为了满足不同用户的需求。当某个单位申请到一个ip地址时，
实际上是获得了具有同样网络号的一块地址空间，其中具体的主机号由该单位自行分配，只需要在管辖范围内无重复的主机号即可。

[![rIoJ8x.png](https://s3.ax1x.com/2020/12/27/rIoJ8x.png)](https://imgchr.com/i/rIoJ8x)

#### A类IP地址

- 1个字节的网络地址和3个字节的主机地址组成，网络地址的最高位必须为0. A类地址可指派的网络数为（2^7-2) 个，这里减2是由于网络号字段中全为0的ip地址为保留地址，表示本网络，而网络号为127的地址保留用于环回测试本机的进程间通信

- 127.0.0.0 到 127.255.255.255 是保留地址，用于回环测试，0.0.0.0 到 0.255.255.255 也是保留地址，用于表示所有的ip地址

- A类IP地址中主机号占3个字节，因此每个A类网络中最大主机数为16777214（2^24-2），这里减2原因是：主机号全为0表示该ip地址为本机所属网络的地址（如一个主机的ip地址为，5.6.7.8，则该主机所在网络地址就是5.0.0.0)，而全1表示所有的主机。
  ip地址空间共有2^32个地址，整个A类地址空间共有2^31个地址，占整个地址空间的50%

#### B类IP地址

- 2个字节的网络地址和2个地址的主机地址组成，网络地址的最高两位必须为10.由于网络号字段的前两位固定，后面的14位物理怎样都不会出现全0或者全1的情况，
因此也不存在减2的问题。
  
- 实际上B类网络地址中128.0.0.0是不可指派的，而可以指派的B类最小网络地址为128.1.0.0，因此B类地址可指派的网络数为16383（2^14-1）个

- B类地址的每个网络上最大主机数为65534（2^16-2）个，这里需要减2是因为要扣除全0或全1的主机号。整个B类地址空间共约有2^30个地址，占整个地址空间的25%

#### C类IP地址

- C类IP地址由3字节的网络地址和1字节的主机地址组成，网络地址的最高位必须为110

- C类网络地址中192.0.0.0 为保留地址不可指派，因此可以指派的网络总数为（2^21-1）个

- C类地址的每个网络上最大主机数为2^8-2。整个C类地址空间共约有2^29个地址，占整个地址空间的12.5%

### 端口

- 端口： 端口号是一个16位整数，最多为65536.

客户端发起连接请求是，客户端端口是操作系统内核临时分配的，称为零时端口；服务器端的端口通常是一个总所周知的端口。

#### 默认端口

````

/* Standard well-known ports.  */
enum
  {
    IPPORT_ECHO = 7,    /* Echo service.  */
    IPPORT_DISCARD = 9,   /* Discard transmissions service.  */
    IPPORT_SYSTAT = 11,   /* System status service.  */
    IPPORT_DAYTIME = 13,  /* Time of day service.  */
    IPPORT_NETSTAT = 15,  /* Network status service.  */
    IPPORT_FTP = 21,    /* File Transfer Protocol.  */
    IPPORT_TELNET = 23,   /* Telnet protocol.  */
    IPPORT_SMTP = 25,   /* Simple Mail Transfer Protocol.  */
    IPPORT_TIMESERVER = 37, /* Timeserver service.  */
    IPPORT_NAMESERVER = 42, /* Domain Name Service.  */
    IPPORT_WHOIS = 43,    /* Internet Whois service.  */
    IPPORT_MTP = 57,




    IPPORT_TFTP = 69,   /* Trivial File Transfer Protocol.  */
    IPPORT_RJE = 77,
    IPPORT_FINGER = 79,   /* Finger service.  */
    IPPORT_TTYLINK = 87,
    IPPORT_SUPDUP = 95,   /* SUPDUP protocol.  */


    IPPORT_EXECSERVER = 512,  /* execd service.  */
    IPPORT_LOGINSERVER = 513, /* rlogind service.  */
    IPPORT_CMDSERVER = 514,
    IPPORT_EFSSERVER = 520,


    /* UDP ports.  */
    IPPORT_BIFFUDP = 512,
    IPPORT_WHOSERVER = 513,
    IPPORT_ROUTESERVER = 520,


    /* Ports less than this value are reserved for privileged processes.  */
    IPPORT_RESERVED = 1024,


    /* Ports greater this value are reserved for (non-privileged) servers.  */
    IPPORT_USERRESERVED = 5000

````


### 保留网段

ipv4地址空间里，划出了一些网段，这些网段不会用做公网上的ip,而仅仅保留作为内部使用。


### 子网掩码

网络IP组成: 网络号+主机号

网络号由子网掩码决定，将IP地址与子网掩码进行"位与”操作，就能得到网络号。

### TCP 动态数据传输

#### 拥塞控制

定义： TCP 必须考虑多个连接共享在有限的带宽上，兼顾效率和公平性的控制。

实现："慢启动”算法，通过一定的规则，慢慢地将网络发送数据的速率增加到一个阈值，超过这个阈值，慢启动就借宿了；"拥塞避免”算法，在这个阶段，TCP不断探测网络状况，随之不断调整拥塞窗口的大小

TCP发送缓冲区数据是否能发送出去，取决于"当前发送窗口大小"和"拥塞窗口大小”，TCP协议取两者最小值作为判断依据。发送字节数大于两者最小值则不能发送。

- 发送窗口：作为单TCP连接，点对点之间的流量控制模型，需要和接受端共同协调来调整大小；用来控制发送和接收端的流量；

- 拥塞窗口：作为多个TCP连接共享带宽的拥塞控制模型，它是发送端独立地根据网络状况来动态调整的；用来控制多条连接公平使用的有限带宽

#### 小数据包

- 小数据包加剧了网络带宽的浪费，引入Nagle算法、延时ACK等机制

- nagle算法：限制大批量的小数据包同时发送。任何一个时刻，未被确认的小数据包不能超过一个。这样，发送端把接下来连续的几个小数据包存储起来，等待接收到前一个小数据包的ACK分组后，再将数据一次性发送出去。
  对延时敏感的应用并不适用。

- 延时ACK:延时ACK在收到数据后并不马上回复，而是累积需要发送的ACK报文，等到有数据需要发送给对端是，将累计的ACK捎带一并发送。


### UDP

- TCP 是一个面向连接的协议，TCP在ip报文的基础上，增加了重传、确认、有序传输、拥塞控制等能力，通信双发在一个确定的上下文，而UDP不具备这种能力

- DNS服务，SNMP服务，对延、丢包不敏感

- 服务端穿件UDP套接字之后，绑定到本地端口，调用recvfrom函数等待客户端的报文发送

- 客户端创建套接字后，调用sendto函数往目标地址和端口发送UDP报文，然后客户端和服务端进入互相应答过程

- UDP 套接字调用connect,绑定本地地址和端口，让我们的程序可以快速获取异步错误信息的通知，同时也获得一定性能的提升。

#### recvfrom  和 sendto 是UDP 用了接收和发送报文的函数

在不调用connect操作的客户端，在服务端不开启的情况下，客户端不会报错，只会阻塞在recvfrom上，等待返回或者超时
如果我们不进行 connect 操作，建立（UDP 套接字——目的地址 + 端口）之间的映射关系，操作系统内核就没有办法把 ICMP 不可达的信息和 UDP 套接字进行关联，也就没有办法将 ICMP 信息通知给应用程序
### 本地套接字

- TCP/UDP即使在本地地址通信，也要走系统王亮协议，而本地套接字，提供了一种单主机跨进程间的调用的手段，减少了协议栈实现的复杂度，效率比TCP/UDP 套接字要高。

- 创建套接字，bind 到本地地址之后，没有再调用listen 和 accept ,使用recvfrom 和 sendto进行数据报的收发和UDP一致

### 服务器端程序，都应该设置SO_REUSEADDR 套接字选项，以便服务端程序可以在很短事件内复用一个端口启动。

在所有 TCP 服务器程序中，调用 bind 之前请设置 SO_REUSEADDR 套接字选项。


### 数据流特征

1. 先调用send函数发送的字节，总在后调用send函数发送字节的前面，这个是由TCP严格保证的

2. 如果发送过程有TCP丢失，但是其后续分组陆续到达，那么TCP协议栈会缓存后续分组，直到前面丢失的分组到达，最终，形成可以被应用程序读取的数据流

### 非阻塞IO

accept和阻塞套接字一起使用就是阻塞的，和非阻塞套接字一起使用就是非阻塞的。阻塞和非阻塞是作用到套接字上的。

#### read

如果套接字对应的接收缓冲区没有数据可读，在非阻塞情况下read调用会立即返回，一般返回EWOULDBLOCK 或者EAGAIN 出错信息。

#### write

如果套接字的发送缓冲区已经达到了极限，不能容纳更多的字节，那么操作系统内核会尽可能从应用程序拷贝数据到发送缓冲区，并立即从writ 函数调用中返回。

#### accept

监听套接字的情况下，客户端发生了RST分节，导致接下来的代码阻塞在"accept"调用下，这里是一个单线程程序，没有办法对其他I/O事件进行服务。不过，是可以对"其他的新连接"进行服务的。


#### connect

在非阻塞TCP 套接字上调用connect函数，会立即返回一个EINPROGRESS 错误。tcp 三次握手正常进行，应用程序可以继续做其他初始化事情。当连接建立成功或者失败时，通过I/O多路复用select、poll等可以进行连接的状态检测




