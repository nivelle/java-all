## 简介

同步系列，这是彤哥想了好久的名字，本来是准备写锁相关的内容，但是java中的CountDownLatch、Semaphore、CyclicBarrier这些类又不属于锁，它们和锁又有很多共同点，都是为了协同多线程的执行，都是一种同步器，所以这里就借用同步来取名字了，也就是“同步系列”的来源。

## 概览

这一篇的内容会比较多，大致包含三大主题：java中的锁、同步器、分布式锁，大致讲的内容如下：

（1）volatile

（2）synchronized

（3）AQS及Condition

（4）ReentrantLock

（5）ReentrantReadWriteLock

（6）StampedLock

（7）CountDownLatch

（8）Semaphore

（9）CyclicBarrier

（10）Phaser

（11）Mysql实现分布式锁

（12）Redis实现分布式锁

（13）Zookeeper实现分布锁

----
## 名词解释

### 公平锁/非公平锁

- 公平锁，是指按照线程申请的顺序获取锁。

- 非公平锁，是指不是按照线程申请的顺序获取锁，有可能后申请的线程反而先获取到锁，假如先来的线程一直获取不到锁，会造成锁饥饿现象。

ReentrantLock中可以通过构造方法指定是否为公平锁，默认为非公平锁，非公平锁的优点在于吞吐量大。

synchronized无法指定为公平锁，一直都是非公平锁。

### 可重入锁

- 可重入锁，是指一个线程获取锁之后再尝试获取锁时会自动获取锁，可重入锁的优点是避免死锁。

ReentrantLock和synchronized都是可重入锁。

### 独享锁/共享锁

- 独享锁，是指锁一次只能被一个线程持有。

- 共享锁，是指锁一次可以被多个线程持有。

ReentrantLock和synchronized都是独享锁，ReadWriteLock的读锁是共享锁，写锁是独享锁。

### 互斥锁/读写锁

- 与独享锁/共享锁的概念差不多，是独享锁/共享锁的具体实现。

ReentrantLock和synchronized都是互斥锁

ReadWriteLock是读写锁

### 乐观锁/悲观锁

- 悲观锁，是指认为对于同一个数据的并发操作必然会发生修改，即使不会发生修改也这么认为，所以一定要加锁。

- 乐观锁，是指认为对于同一个数据的并发操作不一定会发生修改，在更新数据的时候，尝试去更新数据，如果失败就不断尝试。

悲观锁适用于写操作多的场景，乐观锁适用于读操作多的场景。

### 分段锁

- 分段锁，是一种锁的设计思路，它细化了锁的粒度，主要运用在ConcurrentHashMap中，实现高效的并发操作，当操作不需要更新整个数组时，就只锁数组中的一项就可以了。

### 偏向锁/轻量级锁/重量级锁

这三个锁主要是针对synchronized进行优化使用的，主要是通过对象监视器在对象头中的字段来表明的。

- 偏向锁,是指一段同步代码一直被一个线程访问，那么这个线程会自动获取锁，降低获取锁的代价。

- 轻量级锁,是指当锁是偏向锁时，被另一个线程所访问，偏向锁会升级为轻量级锁，这个线程会通过自旋的方式尝试获取锁，不会阻塞，提高性能。

- 重量级锁,是指当锁是轻量级锁时，当自旋的线程自旋了一定的次数后，还没有获取到锁，就会进入阻塞状态，该锁升级为重量级锁，重量级锁会使其他线程阻塞，性能降低。

### 自旋锁

- 自旋锁，是指尝试获取锁的线程不会阻塞，而是循环的方式不断尝试，这样的好处是减少线程的上下文切换带来的开锁，提高性能，缺点是循环会消耗CPU。

### 监视器锁

- synchronized的实现方式，使用`monitorenter`和`monitorexit`来实现。

### mutex锁

- 互斥锁，LockSupport.part()底层是通过mutex实现的。


----
### 并发编程

Java SDK 并发包通过 Lock 和 Condition 两个接口来实现管程，其中 Lock 用于解决互斥问题，Condition 用于解决同步问题。

### Lock

#### 破坏不可抢占条件:

synchronized 没有办法解决。原因是 synchronized 申请资源的时候，如果申请不到，线程直接进入阻塞状态了，而线程进入阻塞状态，释放不了线程已经占有的资源

````

// 支持中断的API:能够响应中断
void lockInterruptibly() throws InterruptedException;
// 支持超时的API:如果线程在一段时间之内没有获取到锁，不是进入阻塞状态，而是返回一个错误，那这个线程也有机会释放曾经持有的锁
boolean tryLock(long time, TimeUnit unit) throws InterruptedException;
// 支持非阻塞获取锁的API:非阻塞地获取锁。如果尝试获取锁失败，并不进入阻塞状态，而是直接返回，那这个线程也有机会释放曾经持有的锁
boolean tryLock();

````

### Condition

- Condition实现了管程模型里面的条件变量

#### 异步编程的支持

- 调用方创建一个子线程，在子线程中执行方法调用，这种调用我们称为异步调用

- 方法实现的时候，创建一个新的线程执行主要逻辑，主线程直接return,这种方法我们称为异步方法
