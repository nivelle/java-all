### 索引

#### 创建唯一索引

```
create unique index uniq_device_no on activity(`device_no`);

```

#### 创建联合索引

```

CREATE INDEX device ON activity (`type`,`device_no`);

```

#### 查看索引

```
show index from activity;

+-------------+------------+----------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| Table       | Non_unique | Key_name       | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible | Expression |
+-------------+------------+----------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| activity |          0 | PRIMARY        |            1 | id          | A         |           3 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
| activity |          0 | uniq_device_no |            1 | device_no   | A         |           3 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
| activity |          1 | device         |            1 | type | A         |           2 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
| activity |          1 | device         |            2 | device_no   | A         |           3 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
+-------------+------------+----------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+

```

#### InnoDB的索引有两类索引，聚集索引(Clustered Index)与普通索引(Secondary Index)。

- InnoDB的每一个表都会有聚集索引(叶子节点存储行记录(row)):

(1)如果表定义了PK，则PK就是聚集索引;

(2)如果表没有定义PK，则第一个非空unique列是聚集索引;

(3)否则，InnoDB会创建一个隐藏的row-id作为聚集索引；

- 普通索引，叶子节点存储了PK的值；

- 无论使用InnoDB还是 MyISAM 存储引擎，默认都会创建一个主键索引，而创建主键索引默认使用B+tree索引。
  
```
1. 如果是 MyISAM 存储引擎，由于MyISAM使用的是辅助索引，索引中每一个叶子结点仅仅记录的是每行数据的物理地址，即行指针。
  
2. 如果是 InnoDB 存储引擎，使用的是聚蔟索引，索引中的叶子节点记录了主键，事务id,用户事务和MVCC的回流指针以及所有的剩余列。
  
```
#### 索引优化

- 尽量避免回表,也即索引覆盖:索引包含要查询的数据,就不需要通过叶子节点的主键值,再去回表查询数据了,减少了IO操作;
  select count(*) 如果不存在辅助索引，此时会通过聚蔟索引来统计行数，如果有辅助索引，则会通过查询辅助索引来统计行数

- 自增字段作为主键优化查询: 如果使用自增主键，插入数据就会按照顺序添加到当前索引节点位置，不需要移动已经有的数据，当页面写满，就会自动开辟一个新页面。

- 前缀索引优化: 减少索引字段大小，可以增加一个页中存储的索引项，有效提高索引的查询速度。 在一些大字符串的字段作为索引时，使用前缀索引可以帮助减少索引项的大小。
  **order by 无法使用前缀索引，无法把前缀索引用作覆盖索引**

- 防止索引失效: 以 %s 开头的的like查询无法利用节点查询数据;使用复合索引时，需要使用索引最左边的列进行查询才可以; 查询条件使用 or 且or的前后条件中有一个列没有索引，那么涉及的索引不会被使用到。
